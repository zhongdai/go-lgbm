# Implementation Plan: LightGBM Model Inference Library

**Branch**: `001-lgbm-model-inference` | **Date**: 2026-02-13 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-lgbm-model-inference/spec.md`

## Summary

Build a pure-Go library that loads LightGBM v3/v4 text-format models
and runs inference, replacing `github.com/dmitryikh/leaves`. The
library re-implements tree traversal, categorical bitset evaluation,
NaN routing, and objective transformations (sigmoid, softmax,
exponential, identity) in pure Go with no CGo. The public API mirrors
`leaves` closely to enable straightforward migration.

## Technical Context

**Language/Version**: Go 1.21+ (generics available, minimum supported)
**Primary Dependencies**: Standard library only (`bufio`, `strconv`,
`strings`, `math`, `sync`). Zero third-party dependencies.
**Storage**: N/A (read-only model files from filesystem or reader)
**Testing**: `go test`, `go test -race`, `go test -bench`
**Target Platform**: Linux, macOS, Windows (all GOARCH)
**Project Type**: Single Go module / library
**Performance Goals**: Prediction throughput within 20% of `leaves`
**Constraints**: Pure Go, no CGo, immutable models, concurrency-safe
**Scale/Scope**: ~2000-3000 LOC for core library + tests

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Leaves Compatibility | PASS | API contract mirrors `leaves` (see contracts/api.go). Migration guide planned. |
| II. Pure Go / No CGo | PASS | Zero dependencies on C libraries. Standard library only. |
| III. LightGBM 3+4 Only | PASS | Parser validates version header, rejects non-v3/v4. |
| IV. Test-First | PASS | Golden-file tests against Python LightGBM for all objective types x both versions. TDD workflow enforced. |
| V. Idiomatic Go API | PASS | `Model`, `Predict`, error returns, godoc, concurrency-safe. No panics. |

**Post-Phase 1 Re-check**: All gates still pass. API contract
confirmed idiomatic. Data model confirms immutability. No CGo
anywhere.

## Project Structure

### Documentation (this feature)

```text
specs/001-lgbm-model-inference/
├── plan.md              # This file
├── research.md          # LightGBM format research
├── data-model.md        # Entity definitions
├── quickstart.md        # Usage examples
├── contracts/
│   └── api.go           # Public API contract
└── tasks.md             # Generated by /speckit.tasks
```

### Source Code (repository root)

```text
lgbm.go                  # Package doc, ModelFromFile, ModelFromReader
model.go                 # Model type, metadata methods
tree.go                  # Tree type, traversal logic
parser.go                # Text-format model parser
parser_header.go         # Header section parsing
parser_tree.go           # Tree section parsing
objective.go             # ObjectiveType enum, transformation functions
predict.go               # Predict, PredictSingle, PredictDense
predict_batch.go         # Batch prediction with goroutine parallelism
errors.go                # Sentinel errors and error types
testdata/                # Golden model files and reference outputs
├── v3/
│   ├── binary.txt       # v3 binary classification model
│   ├── regression.txt   # v3 regression model
│   ├── multiclass.txt   # v3 multiclass model
│   ├── ranking.txt      # v3 ranking model
│   └── *.json           # Expected outputs per model
├── v4/
│   ├── binary.txt       # v4 binary classification model
│   ├── regression.txt   # v4 regression model
│   ├── multiclass.txt   # v4 multiclass model
│   ├── ranking.txt      # v4 ranking model
│   └── *.json           # Expected outputs per model
└── scripts/
    └── generate_golden.py  # Python script to regenerate golden files
```

**Structure Decision**: Flat package layout at repository root
(standard for Go libraries). No `src/` directory — Go convention is
package root == module root. Files are organized by concern (parsing,
prediction, model), not by pattern (models/, services/).

## Research Summary

Key findings from Phase 0 (see [research.md](research.md)):

1. **v3 vs v4 format**: Core tree structure is identical. Only the
   version header string differs. v4 ignores unknown parameters
   from v3 models. Our parser handles both by accepting `version=v3`
   and `version=v4`.

2. **Tree encoding**: Binary tree with negative indices for leaves.
   `decision_type` bit field encodes categorical flag (bit 0) and
   default NaN direction (bit 1).

3. **Categorical splits**: Bitset stored in `cat_threshold` as
   uint32 arrays, boundaries in `cat_boundaries`. Category k goes
   left if bit k is set.

4. **Objective → transformation mapping**: `binary` → sigmoid,
   `multiclass` → softmax, `regression` → identity,
   `poisson`/`gamma`/`tweedie` → exponential.

5. **leaves API surface**: `Ensemble` type with `PredictSingle`,
   `Predict`, `PredictDense`, `PredictCSR`. We mirror all except
   CSR (out of scope for v1). Key addition: our `PredictSingle`
   returns `(float64, error)` instead of just `float64`.

## Complexity Tracking

No constitution violations. No complexity justifications needed.
